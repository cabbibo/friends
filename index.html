<html>

<head>
  <style>

    @font-face {
      font-family: "GeoSans";
      src: url("lib/GeosansLight.ttf");
    }
    html{ color:#fff; background:#000; font-family:"GeoSans"; overflow:hidden }

    #container{
      width      : 100%;
      height     : 100%;
      position   : absolute;
      top        : 0px;
      left       : 0px;
      background : #000;
    }

    #stats{
      position  : absolute;
      bottom    : 0px;
      right     : 0px;
      z-index   : 999;
    }

    a{
      color: #fff;
      position: absolute;
      z-index: 999;
    }

    #loading{

      width:100%;
      text-align:center;
      padding-top:100px;
      font-size:25px;

    }

  </style>
</head>
<body>

  <div id="loading">
    <h1> THESE ARE MY FRIENDS </h1>
    <p> | loading friend fractals | </p>
  </div>

<script src = "lib/underscore.js"           ></script>
<script src = "lib/three.js"                ></script>
<script src = "lib/jquery.min.js"           ></script>
<script src = "lib/stats.min.js"            ></script>
<script src = "lib/TrackballControls.js"    ></script>
<script src = "lib/TextCreator.js"    ></script>
<script src = "lib/ShaderLoader.js"         ></script>
<script src = "lib/Stream.js"               ></script>
<script src = "lib/AudioController.js"      ></script>
<script src = "lib/AudioTexture.js"         ></script>
<script src = "lib/ObjectControls.js"       ></script>
<script src = "lib/leap.js"             ></script>

<script>

  console.log('Loading');

  var container , camera, scene, renderer , stats;

  var sceneSize = 5000;

  var handGeo;
  var skullGeo;
  var tendrilGeo;
  var logoGeo;

  var loaded = 0;
  var neededToLoad = 7;

  var clock = new THREE.Clock();

  var audioController = new AudioController();
  //audioController.mute.gain.value = 0;

  var stream = new Stream(  'audio/palette.mp3',audioController  );

  var lT = THREE.ImageUtils.loadTexture;
  var m = THREE.UVMapping;
  var c = function(){ onLoad() };

  var waterNormal = lT( 'img/normals/water.png' , m , c );
  waterNormal.wrapS = THREE.RepeatWrapping; 
  waterNormal.wrapT = THREE.RepeatWrapping;


  var controller = new Leap.Controller();



  // FRIEND TEXTURES
  var FT = {};
  FT.array = [];

  FM = [];
  var FT_files = [
    'Robbie',
    'Reza',
    'Eddie',
    'Aki',
    'Jono'
  ]

  var urls = [
    'http://robbietilton.com/',
    'http://www.syedrezaali.com/',
    'http://illogictree.com/blog/home/',
    'http://aleksandarrodic.com/',
    'http://jonobr1.com/'
  ]

  var descriptions = [
    '@robbietilton',
    '@rezaali',
    '@eddietree',
    '@akirodic',
    '@jonobr'
  ]

  for( var i = 0; i < FT_files.length; i ++ ){

    var f = FT_files[i];

    var p = 'img/friends/'
    FT[ f ] = lT( p + f + '.png' , m , c );

    FT[ f ].name  = f;
    FT[ f ].url   = urls[i];

    FT.array.push( FT[ f ] );

  }


  var timer = { type:"f" , value:0 }
  var dT = { type:"f" , value:0 }
  var t_audio = { type:"t" , value:audioController.texture}


  var shaders = new ShaderLoader('shaders');

  shaders.load( 'fs-water' , 'water' , 'fragment' );
  shaders.load( 'vs-water' , 'water' , 'vertex' );

  shaders.shaderSetLoaded = function(){
   onLoad();
  }


  function init(){

    createText();

    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera( 
      50 ,
      window.innerWidth / window.innerHeight,
      sceneSize / 100 ,
      sceneSize * 4000
    );

    // placing our camera position so it can see everything
    camera.position.z = 2000 ;
    camera.position.y = 600;
    camera.lookAt( new THREE.Vector3() );


  /*  controls = new THREE.TrackballControls( camera );

    controls.noPan = true;
    controls.noRoll = true;
    controls.noRotate = true; */

    // Getting the container in the right location
    container     = document.createElement( 'div' );
    container.id  = 'container';
    
    document.body.appendChild( container );

    // Getting the stats in the right position
    stats = new Stats();
    stats.domElement.id = 'stats';
    document.body.appendChild( stats.domElement );


    // Setting up our Renderer
    renderer = new THREE.WebGLRenderer({ autoclear:false });

    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );


    // Making sure our renderer is always the right size
    window.addEventListener( 'resize', onWindowResize , false );


    var obj = new THREE.Object3D();
    objectControls = new ObjectControls( camera , obj , controller );
  

    var w = window.innerWidth ;
    var h = window.innerHeight;
    waterTexture = new THREE.WebGLRenderTarget( 2048 , 2048 );
    
    waterCam = camera.clone(); 
    waterCam.position.copy( camera.position );

    waterCam.position.y *= -1;
    //waterCam.up.y = -1;

    waterCam.scale.y *= -1;
    waterCam.lookAt( new THREE.Vector3() );

    scene.add( waterCam );


    

    w = window.innerWidth ;
    h = window.innerHeight;
    uniforms = {
      t_scene:{ type:"t" , value: waterTexture },
      t_normal:{ type:"t" , value: waterNormal },
      t_audio: t_audio,
      lightPos:{type:"v3" , value: new THREE.Vector3( 0 , 300 , -400 ) },
      SS:{ type:"v2", value: new THREE.Vector2( w*2 , h*2 ) },
      timer:timer,
      normalScale:{type:"f",value:1.}
  
    }

    var material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: shaders.vertexShaders.water,
      fragmentShader: shaders.fragmentShaders.water,


    });
    water = new THREE.Mesh(
      new THREE.PlaneGeometry( 10000 , 10000 ),
      material 
    );

    water.rotation.x = -Math.PI/2;

    scene.add( water );

    var geo = new THREE.PlaneGeometry( 200 , 200 );//, 300 );

    for( var i=0; i < FT.array.length; i++ ){

      var mat = new THREE.MeshBasicMaterial({
        map:FT.array[i],
        transparent:true,
        side: THREE.DoubleSide,
        //depthwrite:false,
       // blending:THREE.AdditiveBlending
      });

      var hoverOver = function(){

        this.textMesh.material.opacity = 1;
        this.active = true;
        this.handleMesh.visible = true;


      }

      var hoverOut = function(){

        this.handleMesh.visible = false;
        this.textMesh.material.opacity = .3;
        this.active = false;

      }

      var select = function(){

        console.log('YA');
        window.open( this.url ,'_blank');

      }


    
      var x = (((i+.5) / FT.array.length)-.5) * 2500;
      var y = 300;

      FT.array[i].textMesh.position.x = x;
      FT.array[i].textMesh.position.y = y+400;
      scene.add( FT.array[i].textMesh );
  
      scene.add( FT.array[i].handleMesh );

       FT.array[i].handleMesh.visible = false;


      var m1 = new THREE.Mesh( geo , mat );

      m1.position.y = y;
      m1.position.x = x;
      scene.add( m1 );
      FM.push( m1 );

      m1.hoverOver = hoverOver.bind( m1 );
      m1.hoverOut = hoverOut.bind( m1 );
      m1.select = select.bind( m1 );
      m1.meshGroup = FT.array[i].name;
      m1.url = FT.array[i].url;
      m1.textMesh = FT.array[i].textMesh;
      m1.handleMesh = FT.array[i].handleMesh;

      objectControls.add( m1 );

      var m2 = m1.clone();
      m2.scale.multiplyScalar( 1.4 );
      m2.position.z = -80+ Math.random();
      scene.add( m2 );
      FM.push( m2 );
      
      m2.hoverOver = hoverOver.bind( m2 );
      m2.hoverOut = hoverOut.bind( m2 );
      m2.select = select.bind( m2 );
      m2.meshGroup = FT.array[i].name;
      m2.url = FT.array[i].url;
      m2.textMesh = FT.array[i].textMesh;
      m2.handleMesh = FT.array[i].handleMesh;

      objectControls.add( m2 );


      var m3 = m2.clone();
      m3.scale.multiplyScalar( 1.4 );
      m3.position.z = -160+ Math.random();
      scene.add( m3 );
      FM.push( m3 );

      m3.hoverOver = hoverOver.bind( m3 );
      m3.hoverOut = hoverOut.bind( m3 );
      m3.select = select.bind( m3 );
      m3.meshGroup = FT.array[i].name;
      m3.url = FT.array[i].url;
      m3.textMesh = FT.array[i].textMesh;
      m3.handleMesh = FT.array[i].handleMesh;
      objectControls.add( m3 );






    }


  }


  function animate(){

    objectControls.update();
    audioController.update();

    dT.value = clock.getDelta();
    timer.value += dT.value;

    stats.update();

    //controls.update();

    var t = timer.value;

    for( var i= 0; i < FM.length; i++ ){

      var dir = (i % 2) -.5;
      //FM[i].rotation.x += Math.sin( (i+1) * t * .05) * .01;
      //FM[i].rotation.y += Math.sin( (i+1) * t * .1) * .01;
      FM[i].rotation.z += Math.cos( (i+1) * t * .07) * .01 * dir;

    }
 

    waterCam.position.copy( camera.position );
    waterCam.position.y *= -1;
    waterCam.lookAt( new THREE.Vector3() );

    water.visible = false;
    renderer.render( scene , waterCam  , waterTexture , true);
    water.visible = true;
    renderer.render( scene , camera );

    requestAnimationFrame( animate );

  }

  // Resets the renderer to be the proper size
  function onWindowResize(){

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    waterCam.aspect = window.innerWidth / window.innerHeight;
    waterCam.updateProjectionMatrix();


    renderer.setSize( window.innerWidth, window.innerHeight );
    //waterTexture.setSize( window.innerWidth, window.innerHeight );

    uniforms.SS.value.x = window.innerWidth * 2;
    uniforms.SS.value.y = window.innerHeight * 2;


  }


  function onLoad(){


    loaded ++;

    console.log(loaded );
    if( loaded === neededToLoad ){

      init();
      animate();
      stream.play();

    }

  }


  function createText(){

    var textCreator = new TextCreator();

    for( var i = 0;  i < FT.array.length; i++ ){

      var text = textCreator.createMesh( FT.array[i].name );
      FT.array[ i ].textMesh = text;


      var text = textCreator.createMesh( descriptions[i] );
      text.material.opacity = .3;
     // text.material.visible = false;
      text.material.side = THREE.DoubleSide;
      text.material.blending = THREE.AdditiveBlending;
      text.materialNeedsUpdate = true;

      text.scale.multiplyScalar( 2 );

      text.position.y = 100;
      text.position.z = 700;
      text.rotation.x = - Math.PI / 3;
      FT.array[ i ].handleMesh = text;

    }

  }
  function createParticleGeo(numOf){

    var geometry = new THREE.BufferGeometry();

    var numOf = numOf || 100;
    geometry.addAttribute( 'position', new Float32Array( numOf * 3 ), 3 );
    var positions = geometry.getAttribute( 'position' ).array;
    
    for( var i = 0; i < numOf; i++ ){

     // for( var j = 0; j < 64; j++ ){

       var index = i * 3;
       var x =( ((i+.5)/ numOf ) - .5 ) * 4000;

      positions[ index + 0 ]  = x
      positions[ index + 1 ]  = 0;
      positions[ index + 2 ]  = 0;



     // }

    }

    return geometry;


  }
</script>


</body>
</html>
